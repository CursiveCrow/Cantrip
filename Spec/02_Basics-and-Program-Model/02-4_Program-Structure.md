# 2.4 Program Structure

## Overview

This section specifies the structure of Cursive programs at the compilation unit level. It defines the organization of source files, permitted top-level constructs, declaration ordering constraints, and the program entry point mechanism.

A Cursive program consists of one or more compilation units (source files) that are processed and linked together to form an executable or library. Each compilation unit has a well-defined structure with specific constraints on what declarations may appear at the top level.

---

## 2.4.1 Compilation Units

### 2.4.1.1 Definition and Properties

**Definition 2.23 (Compilation Unit)**: A compilation unit is the source code contained in a single source file, processed as a unit by the compiler.

**Formal properties**:

1. **One-to-one correspondence**: One source file corresponds to exactly one compilation unit
2. **Module identity**: The file path determines the module identity (see §[REF_TBD])
3. **Linkage**: Compilation units are linked together to form a complete program or library
4. **Independence**: Each compilation unit is lexically analyzed and parsed independently
5. **Semantic dependencies**: Semantic analysis may require information from other compilation units

**Notation**: Let CU denote a compilation unit, and let `source_file(CU)` denote the source file path corresponding to CU.

### 2.4.1.2 Well-Formedness Constraints

**Requirement 2.4.1**: A well-formed compilation unit shall satisfy the following constraints:

1. **Encoding validity**: The source file must be valid UTF-8 (§2.1)
2. **Lexical validity**: The source file must be lexically valid, producing a well-formed token stream (§2.2)
3. **Syntactic validity**: The token stream must satisfy the grammar productions in Annex A
4. **Semantic validity**: The compilation unit must satisfy all semantic constraints specified in this specification

**Well-formedness inference rule**:

```
[CU-Well-Formed]
source_file(CU) is valid UTF-8            (§2.1)
lexical_analysis(CU) succeeds             (§2.2)
syntactic_analysis(CU) succeeds           (§2.3)
semantic_analysis(CU) succeeds            (§[REF_TBD])
────────────────────────────────────────────────────
CU is well-formed
```

### 2.4.1.3 Compilation Unit Grammar

A compilation unit consists of a sequence of top-level declarations:

```ebnf
CompilationUnit ::= TopLevelItem*

TopLevelItem ::=
    ImportDeclaration
  | UseDeclaration
  | VariableDeclaration
  | FunctionDeclaration
  | ProcedureDeclaration
  | TypeDeclaration
  | RecordDeclaration
  | EnumDeclaration
  | ModalDeclaration
  | PredicateDeclaration
  | ContractDeclaration
  | EffectDeclaration
  | AttributeDeclaration
```

**Normative reference**: The complete grammar for top-level constructs is specified in Annex A.6.

### 2.4.1.4 Empty Compilation Units

**Requirement 2.4.2**: An empty compilation unit (containing no top-level items) is permitted and well-formed.

**Rationale**: Empty source files may serve as placeholders or may be generated by build tools.

---

## 2.4.2 Top-Level Constructs

### 2.4.2.1 Permitted Declarations

The following declaration forms are permitted at module scope (top level of a compilation unit):

1. **Import and use declarations**:
   - `import module_path`: Brings a module into scope
   - `use module_path::item`: Brings specific items into scope

2. **Variable declarations**:
   - `let name: Type = expr`: Immutable module-level binding
   - `var name: Type = expr`: Mutable module-level binding

3. **Function and procedure declarations**:
   - `function name(params): ReturnType { ... }`: Pure callable
   - `procedure name(params): ReturnType uses effects { ... }`: Effectful callable

4. **Type declarations**:
   - `type Name = Type`: Type alias
   - `newtype Name = Type`: Nominal type wrapper
   - `record Name { fields }`: Product type (struct)
   - `enum Name { variants }`: Sum type (tagged union)
   - `modal Name { states }`: Modal type (state machine)

5. **Predicate declarations**:
   - `predicate Name { ... }`: Interface specification

6. **Contract declarations**:
   - `contract Name { ... }`: Contract specification

7. **Effect declarations**:
   - `effect Name { operations }`: Effect interface

**Top-level grammar summary**:

```ebnf
VariableDeclaration   ::= Visibility? ("let" | "var") Identifier (":" Type)? "=" Expr Separator
FunctionDeclaration   ::= Visibility? "function" Identifier GenericParams? "(" ParamList? ")" (":" Type)? ContractClauses? BlockExpr
ProcedureDeclaration  ::= Visibility? "procedure" Identifier GenericParams? "(" ParamList? ")" UsesClause (":" Type)? ContractClauses? BlockExpr
TypeDeclaration       ::= Visibility? "type" Identifier GenericParams? "=" Type Separator
RecordDeclaration     ::= Visibility? "record" Identifier GenericParams? "{" FieldList? "}"
EnumDeclaration       ::= Visibility? "enum" Identifier GenericParams? "{" VariantList? "}"
ModalDeclaration      ::= Visibility? "modal" Identifier GenericParams? "{" StateList? "}"
PredicateDeclaration      ::= Visibility? "predicate" Identifier GenericParams? "{" PredicateItemList? "}"
ContractDeclaration   ::= Visibility? "contract" Identifier GenericParams? "{" ContractItemList? "}"
EffectDeclaration     ::= Visibility? "effect" Identifier "{" EffectOperationList? "}"
```

### 2.4.2.2 Prohibited Constructs

**Requirement 2.4.3**: The following constructs shall not appear at module scope:

1. **Expression statements**: Arbitrary expressions (e.g., `x + y;`) are not permitted at module scope
2. **Control flow statements**: `if`, `match`, `loop`, `while`, `for`, `break`, `continue` are not permitted at module scope
3. **Local-only constructs**: Block-scoped declarations that do not introduce module-level names

**Rationale**: Module scope is restricted to declarations to maintain a clear separation between compile-time structure (declarations) and runtime behavior (statements).

**Error code**:

- **E2016**: Statement or expression not permitted at module scope

**Example (invalid)**:

```cursive
// ❌ ERROR: Expression statement at module scope
let x = 5
x + 10  // E2016: Statement not permitted at module scope
```

### 2.4.2.3 Visibility Modifiers

**Definition 2.24 (Visibility)**: A visibility modifier controls the accessibility of a declaration from other modules.

**Visibility levels**:

| Modifier | Accessibility | Scope |
|----------|---------------|-------|
| `public` | Unrestricted | Visible to all modules, including external packages |
| `internal` | Package-local | Visible only within the same package |
| `private` | File-local | Visible only within the same compilation unit |
| `protected` | Subtype-local | Visible to subtypes (for predicate implementations) |

**Default visibility**: If no visibility modifier is specified, the default is `internal` (package-local).

**Syntax**:

```ebnf
Visibility ::= "public" | "internal" | "private" | "protected"
```

**Visibility rules**:

```
[Visibility-Module-Level]
Declaration D at module scope
Visibility V specified for D
────────────────────────────────────
D has accessibility level V
```

```
[Visibility-Default]
Declaration D at module scope
No visibility modifier specified for D
────────────────────────────────────
D has accessibility level `internal`
```

**Example**:

```cursive
public function sqrt(x: f64): f64 { ... }      // Public API
internal let MAX_BUFFER_SIZE = 4096             // Package-visible
private function helper(): i32 { ... }          // File-private
```

### 2.4.2.4 Module-Level Initialization

**Definition 2.25 (Module-Level Variable)**: A module-level variable is a variable declared at the top level of a compilation unit with `let` or `var`.

**Initialization semantics**:

1. **Eager initialization**: Module-level variables are initialized before `main` executes
2. **Dependency order**: Variables are initialized in dependency order (topological sort)
3. **Cross-module dependencies**: Variables may depend on variables from other modules

**Initialization algorithm**:

```
Algorithm: initialize_module_variables(modules: Set<Module>) -> void
1. Let G = dependency graph of all module-level variables across all modules
2. Perform topological sort of G to obtain initialization order O
3. For each variable v in O:
   a. Evaluate initializer expression for v
   b. Bind the result to v
4. If cycle detected in step 2:
   - ERROR E2017: Cyclic dependency in module-level variable initialization
```

**Requirement 2.4.4**: Module-level variable initializers shall not create initialization cycles.

**Example (cyclic dependency - invalid)**:

```cursive
// Module A
public let A_VAL = B::B_VAL + 1  // Depends on B_VAL

// Module B
public let B_VAL = A::A_VAL + 1  // Depends on A_VAL (cycle!)
// ❌ ERROR E2017: Cyclic dependency
```

---

## 2.4.3 Declaration Order

### 2.4.3.1 Forward References

**Definition 2.26 (Forward Reference)**: A forward reference is a use of a name that appears lexically before its declaration in the source file.

**Requirement 2.4.5**: Forward references to types, functions, and procedures are permitted within the same compilation unit and across compilation units.

**Two-phase compilation**: Forward references are enabled by the two-phase compilation model (§2.0):

1. **Phase 1 (Declaration Collection)**: All declarations are collected and made visible before type checking
2. **Phase 2 (Type Checking)**: Type checking occurs with all declarations visible

**Forward reference rule**:

```
[Forward-Reference-Allowed]
Declaration D₁ uses name N
Declaration D₂ defines name N
D₁ appears lexically before D₂ in source file
Both D₁ and D₂ are in same compilation unit
────────────────────────────────────────────────
D₁ may reference N (forward reference)
```

### 2.4.3.2 Self-Referential Types

**Requirement 2.4.6**: A type declaration may refer to itself in its definition, provided the reference is through an indirection (pointer, slice, or heap-allocated container).

**Self-reference rule**:

```
[Self-Reference-Valid]
Type T defined as: record T { field: Ptr<T> }
Field type is Ptr<T>, Box<T>, or similar indirection
────────────────────────────────────────────────
Self-reference is valid
```

**Example (valid self-reference)**:

```cursive
record Node {
    value: i32
    next: Ptr<Node>  // ✅ OK: Self-reference through pointer
}
```

**Example (invalid self-reference)**:

```cursive
record Invalid {
    self: Invalid  // ❌ ERROR E2018: Infinite size type
}
```

**Error code**:

- **E2018**: Type has infinite size (direct self-reference without indirection)

### 2.4.3.3 Mutually Recursive Types

**Requirement 2.4.7**: Mutually recursive type definitions are permitted, provided at least one direction uses indirection.

**Mutual recursion rule**:

```
[Mutual-Recursion-Valid]
Type T₁ references type T₂
Type T₂ references type T₁
At least one reference is through indirection
────────────────────────────────────────────────
Mutual recursion is valid
```

**Example (valid mutual recursion)**:

```cursive
record Tree {
    data: i32
    children: Forest  // ✅ Forward reference
}

record Forest {
    trees: [Tree]  // ✅ Indirection through slice
}
```

**Example (invalid mutual recursion)**:

```cursive
record A {
    b: B  // Direct reference (no indirection)
}

record B {
    a: A  // Direct reference (no indirection)
}
// ❌ ERROR E2018: Mutually recursive types with infinite size
```

### 2.4.3.4 Declaration Collection Phase

**Normative statement 2.4.1**: During the first phase of semantic analysis (§2.0.5), all declarations within a compilation unit are collected and made visible before any type checking occurs. This enables forward references.

**Collection algorithm**:

```
Algorithm: collect_declarations(CU: CompilationUnit) -> Scope
1. Let S = new empty scope
2. For each TopLevelItem I in CU:
   a. Extract the declared name N from I
   b. If N already exists in S:
      - ERROR E2019: Duplicate declaration of N
   c. Add N to S with provisional type (to be refined during type checking)
3. Return S
```

**Requirement 2.4.8**: All top-level declarations in a compilation unit shall have unique names within that compilation unit's namespace.

---

## 2.4.4 Program Entry Point

### 2.4.4.1 Main Function Requirement

**Definition 2.27 (Entry Point)**: The entry point of a Cursive program is a function named `main` that serves as the starting point of program execution.

**Requirement 2.4.9**: Every executable Cursive program must define an entry point function named `main`. Library crates (non-executable compilation units) do not require a `main` function.

**Execution semantics**: Execution begins at `main` after static initialization (module-level variable initialization) completes.

### 2.4.4.2 Permitted Main Signatures

**Requirement 2.4.10**: The `main` function shall have one of the following signatures:

**Form 1: No arguments**

```cursive
function main(): i32
```

**Form 2: Command-line arguments**

```cursive
function main(args: [string]): i32
```

**Main signature validation**:

```
[Main-Signature-Valid-1]
Function named `main` declared with signature: () -> i32
────────────────────────────────────────────────────────
Main signature is valid (Form 1)
```

```
[Main-Signature-Valid-2]
Function named `main` declared with signature: ([string]) -> i32
────────────────────────────────────────────────────────────────
Main signature is valid (Form 2)
```

```
[Main-Signature-Invalid]
Function named `main` declared with signature: S -> T
S ≠ () and S ≠ ([string])
OR T ≠ i32
────────────────────────────────────────────────────────
ERROR E2020: Invalid main function signature
```

**Error code**:

- **E2020**: Invalid `main` function signature (must be `() -> i32` or `([string]) -> i32`)

### 2.4.4.3 Return Value Semantics

**Return type**: Both permitted forms of `main` return `i32`, which becomes the process exit code.

**Exit code conventions**:

- **Value 0**: Conventionally indicates successful execution
- **Non-zero values**: Conventionally indicate error conditions
  - Meaning is platform-specific and application-specific
  - Typical range: -128 to 127 (on Unix) or 0 to 255 (on Windows)

**Implementation-defined behavior**: The exact range of exit codes and their interpretation is implementation-defined and platform-dependent.

### 2.4.4.4 Effect Constraints

**Requirement 2.4.11**: The `main` function may be either pure (`function`) or effectful (`procedure`).

**Pure main** (unusual but permitted):

```cursive
function main(): i32 {
    // Pure computation only (no I/O, no mutation of external state)
    result 42
}
```

**Effectful main** (typical):

```cursive
procedure main(args: [string])
    uses io.read, io.write, fs, alloc.heap, process.spawn
: i32 {
    println("Hello, world!")  // I/O permitted via uses clause
    result 0
}
```

**Implementation-provided effect handlers**: If `main` is declared as a `procedure` with a `uses` clause, the implementation provides standard effect handlers for the declared effects:

- `io.read`, `io.write`: Standard input/output
- `fs`: File system operations
- `alloc.heap`: Dynamic memory allocation
- `process.spawn`: Process spawning

**Effect handler provisioning**:

```
[Main-Effect-Handlers]
Main function declared as: procedure main(...) uses E : i32
E is a set of effects
────────────────────────────────────────────────────────────
Implementation provides standard handlers for all effects in E
```

### 2.4.4.5 Uniqueness Constraint

**Requirement 2.4.12**: An executable program shall contain exactly one definition of the `main` function across all compilation units.

**Uniqueness rules**:

```
[Main-Unique]
Program P contains compilation units CU₁, CU₂, ..., CUₙ
CU_i defines function named `main`
CU_j defines function named `main`
i ≠ j
────────────────────────────────────────────────────────
ERROR E2021: Multiple definitions of entry point `main`
```

```
[Main-Missing]
Executable program P contains compilation units CU₁, CU₂, ..., CUₙ
No CU_i defines function named `main`
────────────────────────────────────────────────────────
ERROR E2022: Entry point `main` not found
```

**Error codes**:

- **E2021**: Multiple definitions of entry point `main`
- **E2022**: Entry point `main` not found in executable program

**Library exception**: Non-executable compilation units (libraries) do not require a `main` function and shall not trigger error E2022.

### 2.4.4.6 Program Initialization and Execution Sequence

**Normative Algorithm**: Program execution follows a well-defined sequence of phases:

```
Algorithm: execute_program(P: Program, args: [string]) -> i32

Phase 1: Static Initialization
  1.1. Collect all module-level variable declarations across all compilation units
  1.2. Build dependency graph G of initializer expressions
  1.3. Perform topological sort of G to obtain initialization order O
  1.4. If cycle detected in G:
       - ERROR E2017: Cyclic dependency in module-level initialization
  1.5. For each variable v in O:
       a. Evaluate initializer expression for v
       b. Bind the result to v
       c. If evaluation fails:
          - Terminate with panic

Phase 2: Main Execution
  2.1. Locate main function M
  2.2. If main signature is ([string]) -> i32:
       a. Pass command-line arguments args to M
  2.3. If main signature is () -> i32:
       a. Call M with no arguments
  2.4. If main is effectful (procedure):
       a. Install implementation-provided effect handlers
  2.5. Execute body of M
  2.6. Capture return value (exit code) E from M

Phase 3: Deferred Cleanup
  3.1. Execute all deferred actions in reverse order (§[REF_TBD])
  3.2. Run static destructors for module-level variables in reverse initialization order
  3.3. Finalize effect handlers

Phase 4: Process Exit
  4.1. Return exit code E to operating system
  4.2. Terminate process
```

**Normative guarantees**:

1. **Initialization ordering**: Module-level variables are initialized in dependency order before `main` executes
2. **Deferred execution**: Deferred actions execute after `main` returns (§[REF_TBD])
3. **Cleanup ordering**: Static destructors run in reverse initialization order
4. **Exit code propagation**: The value returned from `main` becomes the process exit code

---

## 2.4.5 Canonical Examples

### Example 1: Complete Well-Formed Source File

The following example demonstrates a complete, well-formed Cursive source file with various top-level constructs:

```cursive
// Module: geometry
// Demonstrates top-level constructs and program structure

// Import declarations
use std::io::println
use std::math::sqrt

// Type declaration (record)
record Point {
    x: f64
    y: f64
}

// Public function declaration
public function distance(p1: Point, p2: Point): f64 {
    let dx = p2.x - p1.x
    let dy = p2.y - p1.y
    result sqrt(dx * dx + dy * dy)
}

// Module-level constant
let ORIGIN: Point = Point { x: 0.0, y: 0.0 }

// Private helper function
private function create_point(x: f64, y: f64): Point {
    result Point { x, y }
}

// Entry point with command-line arguments
function main(args: [string]): i32
    uses io.write
{
    let origin = ORIGIN
    let point = create_point(3.0, 4.0)
    let dist = distance(origin, point)

    println("Distance from origin: {}", dist)

    result 0  // Success
}
```

**Key features demonstrated**:
- Import declarations (`use` statements)
- Type declaration (`record Point`)
- Function declarations with visibility modifiers (`public`, `private`)
- Module-level variable (`let ORIGIN`)
- Forward reference (all declarations visible regardless of order)
- Entry point (`main` function with effects)

### Example 2: Forward References (Mutually Recursive Types)

```cursive
// Mutually recursive types enabled by two-phase compilation

record Tree {
    data: i32
    children: Forest  // ✅ Forward reference to Forest (declared below)
}

record Forest {
    trees: [Tree]  // ✅ Valid: indirection through slice
}

// Both types are visible during type checking
function create_tree(data: i32): Tree {
    result Tree {
        data,
        children: Forest { trees: [] }
    }
}
```

### Example 3: Self-Referential Type (Linked List)

```cursive
record Node {
    value: i32
    next: Ptr<Node>  // ✅ Self-reference through pointer
}

function create_node(value: i32): Node {
    result Node {
        value,
        next: null  // End of list
    }
}
```

### Example 4: Effectful Main Function

```cursive
use std::io::{println, eprintln}
use std::fs

procedure main(args: [string])
    uses io.read, io.write, fs, alloc.heap
: i32 {
    // Effects explicitly declared via uses clause

    if args.len() < 2 {
        eprintln("Usage: program <config>")
        result 1  // Error exit code
    }

    let config_path = args[1]

    // Perform I/O (permitted by uses clause)
    let config = fs::read_to_string(config_path) match {
        Ok(contents) => contents,
        Err(e) => {
            eprintln("Error reading config: {}", e)
            result 1
        }
    }

    println("Config loaded: {} bytes", config.len())
    result 0  // Success
}
```

**Key features demonstrated**:
- Procedure declaration (effectful callable)
- `uses` clause declaring required effects
- Command-line argument handling
- Error handling with early return
- I/O operations enabled by effect system

---

## 2.4.6 Error Codes

This section defines error codes related to program structure:

- **E2016**: Statement or expression not permitted at module scope
- **E2017**: Cyclic dependency in module-level variable initialization
- **E2018**: Type has infinite size (invalid self-reference or mutual recursion)
- **E2019**: Duplicate declaration at module scope
- **E2020**: Invalid `main` function signature
- **E2021**: Multiple definitions of entry point `main`
- **E2022**: Entry point `main` not found in executable program

---

## 2.4.7 Conformance Requirements

A conforming implementation shall satisfy the following requirements with respect to program structure:

1. **Compilation unit processing** (§2.4.1): The implementation shall process each source file as a distinct compilation unit.

2. **Top-level construct restrictions** (§2.4.2): The implementation shall reject statements and expressions at module scope (error E2016).

3. **Visibility enforcement** (§2.4.2.3): The implementation shall enforce visibility modifiers according to the specified accessibility levels.

4. **Forward reference support** (§2.4.3): The implementation shall support forward references through two-phase compilation.

5. **Self-reference validation** (§2.4.3.2): The implementation shall reject types with invalid self-references (error E2018).

6. **Main function validation** (§2.4.4): The implementation shall validate `main` function signatures and enforce uniqueness constraints (errors E2020, E2021, E2022).

7. **Initialization ordering** (§2.4.4.6): The implementation shall initialize module-level variables in dependency order and detect cycles (error E2017).

---

## 2.4.8 Notes and Examples

### Informative Note 1: Module System

The program structure specified in this section is foundational for the module system, which is specified in detail in §[REF_TBD]. The module system provides:
- Hierarchical organization of compilation units
- Namespace management
- Dependency resolution
- Visibility control across module boundaries

### Informative Note 2: Separate Compilation

Compilation units may be compiled separately (incremental compilation) or together (whole-program compilation). The specification supports both compilation strategies. Separate compilation requires:
- Interface files or metadata to communicate declarations across compilation units
- Linker to resolve cross-compilation-unit references

### Informative Note 3: Static vs Dynamic Initialization

Some languages distinguish between static initialization (compile-time or load-time) and dynamic initialization (runtime). Cursive specifies that module-level variable initialization occurs before `main` executes, but does not mandate whether this happens at compile-time, load-time, or early runtime. Implementations may optimize pure initializers to compile-time evaluation where possible.

---

**End of Section 2.4: Program Structure**
