---
alwaysApply: true
---

CRITICAL NOTE: These instructions only apply if you are NOT ACTING AS A REVIEWER. As a reviewer your task is to ensure the content provided to you for review aligns with the spec, the language's design goals, and is of maximum quality and clarity, while being ergonomic and understandable. As a reviewer you do NOT submit your review for further review, and instead must return your review directly to the requestor.

<mission>Produce correct Cursive code and spec‑quality prose faithful to Cursive semantics only. This is not Rust. Do not import Rust borrow checking, lifetimes, aliasing rules, traits semantics, or sugar. Where examples in ancillary docs appear Rust‑like, you MUST still emit canonical Cursive.</mission>

<cursive-language-rules>
Cursive (previously known as Cantrip) is a general-purpose systems programming language designed for memory safety, deterministic performance, and AI-assisted development. It achieves these goals through:

- **Lexical Permission System (LPS)**: Compile-time memory safety without garbage collection or borrow checking
- **Explicit Contracts**: Preconditions and postconditions as executable specifications
- **Effect System**: Compile-time tracking of side effects, allocations, and I/O
- **Modal System**: State machines as first-class types with compile-time verification
- **Memory Regions**: Explicit lifetime control with zero-overhead allocation
- **Comptime Metaprogramming**: Compile-time code generation without macros
- **File-Based Modules**: Code organization through file system structure

Cursive compiles to native code with performance matching C/C++ while providing memory safety guarantees through region-based lifetime management.

**Design Philosophy:**

1. **Explicit over implicit** - All effects, lifetimes, and permissions visible in code
2. **Local reasoning** - Understanding code must minimal global context
3. **Zero abstraction cost** - Safety guarantees without runtime overhead
4. **LLM-friendly** - Predictable patterns for AI code generation
5. **Simple ownership** - No borrow checker complexity
6. **No macros** - Metaprogramming through comptime only for predictability

**Safety Model:**

- **Prevents**: Use-after-free, double-free, memory leaks
- **Provides**: Deterministic deallocation, zero GC pauses
- **Does NOT prevent**: Aliasing bugs, data races (programmer's responsibility)

<normative-instructions>
- **No Rustisms**. No ? operator, no lifetime params ('a), no &mut exclusivity claims, no trait/impl substitutions for contracts, no imported unsafe sugar. (Quick Reference deprecates requires/ensures/needs; use uses/must/will.)
- **Regions not lifetimes**. Use explicit region { ... } with LIFO deallocation; do not allow region‑allocated values to escape.
- **Permissions & effects**. Effects are part of function/procedure types; calls are legal only when required effects are available.
- **Contracts**. Use uses (effects), must (pre), will (post). Never rename them.
- **Statements/layout**. Newlines terminate statements; only the four continuation cases allow line continuation (unclosed delimiters, trailing operator, leading dot, leading pipeline).
  </normative-instructions>
